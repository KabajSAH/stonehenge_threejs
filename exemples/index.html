<!DOCTYPE html>
<html lang="en">
	<head>
		<title>TP1</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, max_intimum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>
	<body>
		<script type="module">
			import * as THREE from '../build/three.module.js'; // importation de THREE
			import { OrbitControls } from "../jsm/OrbitControls.js";
            import {GUI} from "../jsm/dat.gui.module.js";

			let camera, scene, renderer; // moteur de rendu web

			let stone = []; // tableau

			let spotLight, lightHelper, shadowCameraHelper, gui; // Lumières

			const listener = new THREE.AudioListener();
			const sound = new THREE.Audio( listener );
			const audioLoader = new THREE.AudioLoader();

			const max_int = 5; // nombre de pierres à l'intérieur
			const max_ext = 20; // nombre de pierres à l'extérieur
			const max_small = 80; // nombre de petites pierres
			const espacement = 40/3;
			const move_speed = 4; // Vitesse de déplacement de la caméra
			const rotate_speed = Math.PI/100; // Vitesse de rotation de la caméra

			let W = false, S = false, A = false, D = false, E = false, Q = false, UP = false, DOWN = false, LEFT = false, RIGHT = false, SPACE = false, SHIFT = false;

			init();
            buildGui();
			animate();


			function init() {

			    //Initialisation du moteur de rendu
			    renderer = new THREE.WebGLRenderer({antialias: true});
			    renderer.setPixelRatio(window.devicePixelRatio);
			    renderer.setSize(window.innerWidth, window.innerHeight);
			    document.body.appendChild(renderer.domElement);


			    // Gestion des ombres
			    renderer.shadowMap.enabled = true;
			    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
			    renderer.outputEncoding = THREE.sRGBEncoding;

			    window.addEventListener('resize', onWindowResize);

			    // SETUP DE LA CAMERA + SCENE

			    camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 10000); // FOV 20, aspect ratio adapté à la fenêtre, distance d'affichage 1 à 10000

			    camera.position.set(0, 250, 700); // caméra reculée
			    camera.rotation.x = -0.4; // caméra regarde vers le bas

			    /* POUR REGARDER EN-DESSOUS */
			    // camera.position.set(0,-250,700);
			    // camera.rotation.x = 0.4;

			    scene = new THREE.Scene(); // création d'une scène

			//Lumière

			    {
						  const ambient = new THREE.AmbientLight(0xffffff, 0.4);
			        scene.add( ambient );

			        spotLight = new THREE.SpotLight( 0xFFF7D2, 2 );
							spotLight.position.set( 1500, 2000, 0 );
			        spotLight.angle = Math.PI / 4;
			        spotLight.penumbra = 0.4;
			        spotLight.decay = 2;
			        spotLight.distance = 6000;

			        spotLight.castShadow = true;
			        spotLight.shadow.mapSize.width = 512;
			        spotLight.shadow.mapSize.height = 512;
			        spotLight.shadow.camera.near = 10;
			        spotLight.shadow.camera.far = 200;
			        spotLight.shadow.focus = 1;
			        scene.add( spotLight );
			    }


					// Audio Listener
					camera.add( listener );


			    // OrbitControls
			    const controls = new OrbitControls( camera, renderer.domElement );
			    controls.minDistance = 10;
			    controls.maxDistance = 2000;
			    controls.enablePan = false;

			    // PARAMETRES DES PIERRES + SOL


			    // EXTERIEUR
			    const stone_ext = new THREE.TextureLoader().load('./textures/stone.png');	// texture des pierres à l'extérieur
			    const material_ext = new THREE.MeshPhongMaterial({map: stone_ext}); 			// matériau basé sur cette texture
			    const geometry_ext = new THREE.BoxGeometry(30, 80, 15); 					// forme des pierres à l'extérieur

			    // INTERIEUR
			    const stone_int = new THREE.TextureLoader().load('./textures/stone.png'); // texture des pierres à l'intérieur
			    const material_int = new THREE.MeshPhongMaterial({map: stone_int}); // matériau basé sur cette texture
			    const tallStone_int = new THREE.BoxGeometry(30, 120, 20); // forme des pierres verticales à l'intérieur
			    const longStone_int = new THREE.BoxGeometry(60, 20, 30); // forme des pierres horizontales à l'intérieur

			    // MINIPIERRES
			    const stone_small = new THREE.TextureLoader().load('./textures/stone.png');
			    const material_small = new THREE.MeshPhongMaterial({map: stone_small});
			    const geometry_small = new THREE.BoxGeometry(8,20,4);

			    // SOL
			    const grass = new THREE.TextureLoader().load('./textures/ground.jpg'); // texture du sol
			    const materialGeo = new THREE.MeshPhongMaterial({map: grass}); // matériau basé sur cette texture
			    const groundGeo = new THREE.BoxGeometry(2000,0.1, 4000); // dimensions du sol

			    const ground = new THREE.Mesh(groundGeo, materialGeo); // création du sol avec les dimensions et le matériau
			    ground.rotation.y = - Math.PI * 0.5;
			    ground.position.y = 0;
			    ground.receiveShadow = true;
			    scene.add(ground);

					spotLight.target.position.x = ground.position.x;
					spotLight.target.position.z = ground.position.z;

			    //SKYBOX
			    scene.background = new THREE.TextureLoader().load('./textures/sky3.png') // ajout du ciel


			    // PIERRES DE L'EXTERIEUR

			    // PILIERS
			    for (let i = 0; i < max_ext; i++) {
			        stone.push(new THREE.Mesh(geometry_ext, material_ext));
			        stone[i].receiveShadow = true;
			        stone[i].castShadow = true;
			        stone[i].position.x = espacement * max_ext * Math.cos(i * Math.PI*2 / max_ext);
			        stone[i].position.y = 40
			        stone[i].position.z = espacement * max_ext * Math.sin(i * Math.PI*2 / max_ext);
			        stone[i].rotation.y = Math.PI / 2 - i * Math.PI*2 / max_ext;
			        scene.add(stone[i]);
			    }

			    // DALLES
			    for (let i = 0; i < max_ext; i++) {
			        stone.push(new THREE.Mesh(geometry_ext, material_ext));
			        stone[i + max_ext].receiveShadow = true;
			        stone[i+ max_ext].castShadow = true;
			        stone[i + max_ext].position.y = 87.5;
			        stone[i + max_ext].position.x = espacement * max_ext * Math.cos((i + 0.5) * Math.PI*2 / max_ext);
			        stone[i + max_ext].position.z = espacement * max_ext * Math.sin((i + 0.5) * Math.PI*2 / max_ext);
			        stone[i + max_ext].rotation.x += Math.PI/2;
			        stone[i + max_ext].rotation.z = (i + 0.5) * Math.PI*2 / max_ext;
			        scene.add(stone[i + max_ext]);
			    }


			    // PIERRES DE L'INTERIEUR

			    for (let i = 1; i < max_int; i++) {

			        let stone1 = new THREE.Mesh(tallStone_int, material_int);
			        stone1.position.set(35, 0, 0);
			        stone1.receiveShadow = true;
			        stone1.castShadow = true;
			        let stone2 = new THREE.Mesh(tallStone_int, material_int);
			        stone2.position.set(-35, 0, 0);
			        stone2.receiveShadow = true;
			        stone2.castShadow = true;
			        let stone3 = new THREE.Mesh(longStone_int, material_int);
			        stone3.position.set(0, 70, 0);
			        stone3.receiveShadow = true;
			        stone3.castShadow = true;

			        let stoneGroup = new THREE.Group();

			        stoneGroup.add(stone1);
			        stoneGroup.add(stone2);
			        stoneGroup.add(stone3);

			        stoneGroup.position.set(2 * espacement * max_int * Math.cos(i * Math.PI / (max_int / 2)), 60, 2 * espacement * max_int * Math.sin(i * Math.PI / (max_int / 2)));
			        stoneGroup.rotation.y = Math.PI / 2 - i * Math.PI / (max_int / 2);

			        scene.add(stoneGroup);
			    }

			//Petites pierres

			for (let i = 0; i < max_small; i++){


			        const small_stone = new THREE.Mesh(geometry_small, material_small);
			        small_stone.receiveShadow = true;
			        small_stone.castShadow = true;
			        small_stone.position.set(espacement/5 * max_small * Math.cos(i * Math.PI / (max_small/2)), 10, espacement/5 * max_small * Math.sin(i * Math.PI / (max_small/2)));
			        small_stone.rotation.y = Math.PI / 2 - i * Math.PI / (max_small/2);
			        if(Math.floor(Math.random() * 3) !== 0)scene.add(small_stone);
			}

			}

			function onWindowResize() {

			    camera.aspect = window.innerWidth / window.innerHeight;
			    camera.updateProjectionMatrix();

			    renderer.setSize(window.innerWidth, window.innerHeight);

			}

			function animate() {

			    requestAnimationFrame(animate);

			    renderer.render(scene, camera);

			    if(W)camera.translateZ(-move_speed);
			    if(A)camera.translateX(-move_speed);
			    if(S)camera.translateZ(move_speed);
			    if(D)camera.translateX(move_speed);

			    if(UP)camera.rotateX(rotate_speed);
			    if(LEFT)camera.rotateY(rotate_speed);
			    if(DOWN)camera.rotateX(-rotate_speed);
			    if(RIGHT)camera.rotateY(-rotate_speed);
			    if(Q)camera.rotateZ(rotate_speed);
			    if(E)camera.rotateZ(-rotate_speed);

			    if(SPACE)camera.translateY(move_speed);
			    if(SHIFT)camera.translateY(-move_speed);

				//Camera COllision with the ground
			    if (camera.position.y < 3)camera.position.y = 3;

			}


			//déplacement de la camera

			//à l'appui
			document.addEventListener("keydown", (e) => {
			    switch (e.code){
			//PERMET DE DEPLACER LA CAMERA DANS LE PLAN
			        case 'KeyW':
			            W = true;
			            break;
			        case 'KeyA':
			            A = true;
			            break;
			        case 'KeyS':
			            S = true;
			            break;
			        case 'KeyD':
			            D = true;
			            break;

			//PERMET DE TOURNER LA CAMERA DANS LE PLAN
			        case 'ArrowUp':
			            UP = true;
			            break;
			        case 'ArrowLeft':
			            LEFT = true;
			            break;
			        case 'ArrowDown':
			            DOWN = true;
			            break;
			        case 'ArrowRight':
			            RIGHT = true;
			            break;
			        case 'KeyQ':
			            Q = true;
			            break;
			        case 'KeyE':
			            E = true;
			            break;


			//PERMET DE MONTER ET DESCENDRE DANS LE PLAN
			     case 'Space':
			            SPACE = true;
			            break;
			     case 'ShiftLeft':
			            SHIFT = true;
			            break;


			        //REMETTRE LES POSITIONS DE DEPART
			        case 'KeyR':
			            camera.position.set(0, 250, 700);
			            camera.rotation.set(-0.4,0,0);
			            break;

					 case 'KeyY':
					 audioLoader.load( './sounds/belupacito.mp3', function( buffer ) {
						 sound.setBuffer( buffer );
						 sound.setLoop( true );
						 sound.setVolume( 0.2 );
						 sound.play();
					 });
			    }
			})


			//au relâchement
			document.addEventListener("keyup", (e) => {
			    console.log(e.code);
			    switch (e.code){
			        //PERMET DE DEPLACER LA CAMERA DANS LE PLAN

			        case 'KeyW':
			            W = false;
			            break;
			        case 'KeyA':
			            A = false;
			            break;

			        case 'KeyS':
			            S = false;
			            break;
			        case 'KeyD':
			            D = false;
			            break;

			        //PERMET DE TOURNER LA CAMERA DANS LE PLAN
			        case 'ArrowUp':
			            UP = false;
			            break;
			        case 'ArrowLeft':
			            LEFT = false;
			            break;
			        case 'ArrowDown':
			            DOWN = false;
			            break;
			        case 'ArrowRight':
			            RIGHT = false;
			            break;
			        case 'KeyQ':
			            Q = false;
			            break;
			        case 'KeyE':
			            E = false;
			            break;


			        //PERMET DE MONTER ET DESCENDRE DANS LE PLAN
			        case 'Space':
			            SPACE = false;
			            break;
			        case 'ShiftLeft':
			            SHIFT = false;
			            break;

			    }
			})


            function buildGui() {

                gui = new GUI();

                const params = {
                    'light color': spotLight.color.getHex(),
                    intensity: spotLight.intensity,
                    distance: spotLight.distance,
                    angle: spotLight.angle,
                    penumbra: spotLight.penumbra,
                    decay: spotLight.decay,
                    focus: spotLight.shadow.focus
                };

                gui.addColor( params, 'light color' ).onChange( function ( val ) {

                    spotLight.color.setHex( val );

                } );

                gui.add( params, 'intensity', 0, 2 ).onChange( function ( val ) {

                    spotLight.intensity = val;

                } );


                gui.add( params, 'distance', 4000, 8000 ).onChange( function ( val ) {

                    spotLight.distance = val;

                } );

                gui.add( params, 'angle', 0, Math.PI / 3 ).onChange( function ( val ) {

                    spotLight.angle = val;

                } );

                gui.add( params, 'penumbra', 0, 1 ).onChange( function ( val ) {

                    spotLight.penumbra = val;

                } );

                gui.add( params, 'decay', 1, 2 ).onChange( function ( val ) {

                    spotLight.decay = val;

                } );

                gui.add( params, 'focus', 0, 1 ).onChange( function ( val ) {

                    spotLight.shadow.focus = val;

                } );

                gui.open();

            }


		</script>
	</body>
</html>
